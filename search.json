[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Julia Implementation for Adaptive Moving Mesh Methods",
    "section": "",
    "text": "This book is a collection of notes and exercieses for the textbook “Adaptive Moving Mesh Methods” (Huang and Russell 2011) with Julia Implementation. The source code of the book can be found at MMPDELab in Matlab.\n\n\n\n\nHuang, Weizhang, and Robert D. Russell. 2011. Adaptive Moving Mesh Methods. Vol. 174. Applied Mathematical Sciences. New York, NY: Springer New York. https://doi.org/10.1007/978-1-4419-7916-2.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Preface</span>"
    ]
  },
  {
    "objectID": "Ch1.html",
    "href": "Ch1.html",
    "title": "2  Chapter 1",
    "section": "",
    "text": "2.1 Burger’s Equation\nusing Pkg \nPkg.activate(\".\")\n\nusing Plots \nusing DifferentialEquations\nusing ModelingToolkit\nusing LinearAlgebra \nusing Symbolics\n\n\nfunction f_bound(x)\n    return zeros(size(x))\nend\n\nfunction f_init(x)\n    return sin(2*π*x) + 0.5 * sin(π*x)\nend\n\nfunction get_rho(v_xs::AbstractVector, v_us::AbstractVector)\n    v_uxx = get_uxx(v_xs, v_us)\n    α = get_alpha(v_xs, v_uxx)\n    #v_rho = (1. .+ alpha^-1 .* v_uxx.^2).^(1/3.)\n    v_rho = (1. .+ (v_uxx.^2) ./ α).^(1/3)\n    v_rho = _averaging(v_rho)\n    v_rho = _averaging(v_rho)\n    v_rho = _averaging(v_rho)\n    v_rho = _averaging(v_rho)\n    v_rho = _averaging(v_rho)\n    return v_rho \nend\n\n\nfunction get_alpha(v_xs::AbstractVector, v_uxx::AbstractVector)\n    x_diff = _diff(v_xs, -1, 0)\n    u_xx_j = v_uxx[2:end]\n    u_xx_jm1 = v_uxx[1:end-1]\n\n    _alpha = sum(0.5 .* x_diff .* (abs.(u_xx_j).^(2/3) .+ abs.(u_xx_jm1).^(2/3)))^3.\n    alpha = max(1., _alpha)\n    return alpha \nend\n\nfunction get_init(ngrid::Integer)\n    v_xs0 = range(0, 1, length=ngrid)\n    v_us0 = f_init.(v_xs0)\n    return [v_xs0; v_us0]\nend\n\n\nfunction get_dxdt(v_xs, v_us, tau)\n    N = length(v_xs)\n    dxi = 1. / (N-1)\n    v_ux = get_ux(v_xs, v_us)\n    v_rho = get_rho(v_xs, v_us)\n    v_dx_forward = _diff(v_xs, 0, +1)\n    v_dx_backward = _diff(v_xs,-1,0)\n\n    _v_dx = 0.5 .* (v_rho[3:end] .+ v_rho[2:end-1]) .* v_dx_forward[2:end] - 0.5 .* (v_rho[2:end-1] .+ v_rho[1:end-2]) .*v_dx_backward[1:end-1]\n    coeff = 1. ./ (v_rho[2:end-1] .* tau .* dxi^2)\n    _v_dx = coeff .* _v_dx\n    return [0.; _v_dx; 0.]\nend\n\n\nfunction get_dudt(v_xs, v_us, v_dxdt, ϵ::AbstractFloat)\n    dx_center = _diff(v_xs, -1, +1)\n    dx_forward = _diff(v_xs, 0, +1)[2:end]\n    dx_backward = _diff(v_xs, -1, 0)[1:end-1]\n\n    du_forward = _diff(v_us, 0, +1)[2:end]\n    du_backward = _diff(v_us, -1, 0)[1:end-1]\n    du_center = _diff(v_us, -1, +1)\n    du_center_sq = _diff(v_us .^2, -1, +1)\n\n    dux_center = du_center ./ dx_center\n    dux_forward = du_forward ./ dx_forward\n    dux_backward = du_backward ./ dx_backward\n\n    _v_dudt = dux_center .* v_dxdt[2:end-1] .+ 2 * ϵ .* (dux_forward .- dux_backward) ./ dx_center .- 0.5 .* du_center_sq ./ dx_center\n\n    v_duxt = [0; _v_dudt; 0]\n    return v_duxt\nend\n\nfunction get_ux(v_xs, v_us)\n    dv_us = _diff(v_us, -1, +1)\n    dv_xs = _diff(v_xs, -1, +1)\n    v_ux = dv_us ./ dv_xs\n    du0 = (v_us[2] - v_us[1]) / (v_xs[2] - v_xs[1])\n    duN = (v_us[end] - v_us[end-1]) / (v_xs[end] - v_xs[end-1])\n    v_ux = [du0; v_ux; duN]\n    return v_ux\nend\n\nfunction get_uxx(v_xs, v_us)\n    dv_us_right = _diff(v_us, 0, +1)[2:end]\n    dv_xs_right = _diff(v_xs, 0, +1)[2:end]\n    v_ux_right = dv_us_right ./ dv_xs_right\n\n    dv_us_left = _diff(v_us, -1, 0)[1:end-1]\n    dv_xs_left = _diff(v_xs, -1, 0)[1:end-1]\n    v_ux_left = dv_us_left ./ dv_xs_left\n\n    v_dx = _diff(v_xs, -1, +1)\n    _v_uxx = (v_ux_right .- v_ux_left) ./ (v_dx ./ 2.)\n\n    x = v_xs \n    u = v_us \n    N = length(v_xs)\n\n    uxx_0 = 2. * ( (x[2] - x[1])*(u[3] - u[1]) - (x[3] - x[1])*(u[2] - u[1]) ) / ((x[3]-x[1])*(x[2]-x[1])*(x[3]-x[2]))\n    uxx_N = 2. * ((x[end-1]-x[end])*(u[end-2] - u[end]) - (x[end-2]-x[end])*(u[end-1]-u[end])) / ((x[end-2]-x[end])*(x[end-1]-x[end])*(x[end-2]-x[end-1]))\n    v_uxx = [uxx_0; _v_uxx; uxx_N]\n    return v_uxx \nend\n\nfunction _diff(arr, left, right)\n    arr_p = arr[-left+right+1:end]\n    arr_m = arr[1:end-(-left+right)]\n    darr = arr_p .- arr_m \n    return darr\nend\n\nfunction _averaging(arr)\n    v_m1 = @view arr[1:end-2]\n    v_m = @view arr[2:end-1]\n    v_p1 = @view arr[3:end]\n\n    v_arr_smooth = 0.25 .* v_m1 .+ 0.5 .* v_m .+ 0.25 .* v_p1 \n    v1 = 0.5 * arr[1] + 0.5 * arr[2]\n    vN = 0.5 * arr[end] + 0.5 * arr[end-1]\n    return [v1; v_arr_smooth; vN]\nend\n\n\nfunction f!(dy, y, p, t)\n    τ, ϵ, ngrid = p\n    v_xs = y[1:ngrid]\n    v_us = y[ngrid+1:end]\n    dxdt = dy[1:ngrid]\n    dudt = dy[ngrid+1:end]\n\n    dxdt = get_dxdt(v_xs, v_us, τ)\n    dudt = get_dudt(v_xs, v_us, dxdt, ϵ)\n    dy[1:end] = [dxdt; dudt]\nend\n\nfunction main(ngrid)\n    τ = 1e-2\n    ϵ = 1e-4\n    tspan = (0., 1.0)\n    p = (τ, ϵ, ngrid)\n    y0 = get_init(ngrid)\n\n    dy0 = copy(y0)\n    #jac_sparsity = Symbolics.jacobian_sparsity((dy, y) -&gt; f!(dy, y, p, 0.0), dy0, y0)\n    #@show jac_sparsity\n\n    f = ODEFunction(f!)#; jac_prototype = float.(jac_sparsity))\n    prob = ODEProblem(f, y0, tspan, p)\n    sol = solve(prob, Kvaerno3(), reltol=1e-8, abstol=1e-8)\n    return sol\nend\n\nfunction plot_sol(sol, ngrid)\n    m = plot()\n    for t in [0, 0.2, 0.4, 0.6, 0.8, 1.0]\n        _sol = sol(t)\n        x = _sol[1:ngrid]\n        m = plot!(m, x, _sol[ngrid+1:end], label=\"t=$t\", marker=(:circle,5))\n    end\n    xlabel!(m, \"x\")\n    ylabel!(m, \"u\")\n    #savefig(m, \"img/MovFD_Burgers.png\")\n    display(m)\nend\n\nfunction plot_grids(sol, ngrid)\n    t = 0.:0.01:1.0 \n    sols = sol(t)\n    m = plot(legend=false)\n    for i in 1:ngrid \n        plot!(m, getindex.(sols.u, i),t, color=:black)\n    end\n    xlabel!(m, \"x\")\n    ylabel!(m, \"t\")\n    #savefig(m, \"img/MovFD_Burgers_grids.png\")\n    display(m)\nend\n\n\n\n\nngrid=41\n@time sol = main(ngrid);\nplot_sol(sol, ngrid);\nplot_grids(sol, ngrid);\n\n  4.088894 seconds (18.04 M allocations: 2.832 GiB, 20.27% gc time, 90.79% compilation time)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Chapter 1</span>"
    ]
  },
  {
    "objectID": "Ch2-2.html",
    "href": "Ch2-2.html",
    "title": "3  Chapter 2.2",
    "section": "",
    "text": "3.1 Equidistribution 1\nFor a continuous function \\(\\rho = \\rho(x) &gt; 0\\), \\(x\\in [a,b]\\). The equidistribution finds a mesh \\(\\mathcal{J}_h:x_1 = a &lt; x_2 &lt; \\dots &lt; x_N = b\\) subh that\n\\[\n\\int^{x_2}_{x_1}  \\rho (x) dx = \\dots = \\int^{x_N}_{x_{N-1}} \\rho(x) dx\n\\tag{3.1}\\]\nwhere\nFror computation. Rewrite Equation 3.1 as\n\\[\n(x_j - x_{j-1})\\braket{\\rho}_{I_j} = \\frac{\\sigma}{(N-1)}, \\quad j=2,\\dots, N\n\\]\nBy coordinate transformation, \\(x = x(\\xi):[0,1] \\to [a,b]\\):\n\\[\nx_j = x(\\xi_j), \\quad j=1,\\dots, N\n\\]\nwhere\n\\[\\xi_j = \\frac{j-1}{N-1}, \\quad j=1, \\dots, N\\]\nA uniform mesh on \\([0,1]\\), then\n\\[\n\\int^{x(\\xi_j)}_{a} \\rho(x) dx = \\sigma \\xi, \\quad \\forall \\xi \\in (0,1)\n\\]\nBy differentiating with respect to \\(\\xi\\),\n\\[\n\\rho(x) \\frac{dx}{d\\xi} = \\sigma\n\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2.2</span>"
    ]
  },
  {
    "objectID": "Ch2-2.html#equidistribution",
    "href": "Ch2-2.html#equidistribution",
    "title": "3  Chapter 2.2",
    "section": "",
    "text": "\\(\\rho\\): mesh density specification function\n\n\nProposition 3.1 (Unique equdistributing mesh of \\(N\\) points) For \\(\\rho &gt; 0\\), there exists a unique equidistributing mesh of \\(N\\) points\n\\[\n\\int^{x_j}_{a} \\rho(x)dx = \\frac{j-1}{N-1}\\sigma, \\quad j = 1,\\dots, N\n\\]\nwhere\n\\[\n\\sigma = \\int^{b}_{a} \\rho(x) dx\n\\]\n\n\n\n\n\\(I_j = (x_{j-1}, x_j)\\)\n\\(\\braket{\\rho}_{I_j}\\): integral average of \\(\\rho(x)\\). \\[\n  \\braket{\\rho}_{I_j} = \\frac{1}{x_j - x_{j-1}}\\int^{x_j}_{x_{j-1}} \\rho(x) dx\n  \\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2.2</span>"
    ]
  },
  {
    "objectID": "Ch2-2.html#de-boors-algorithm",
    "href": "Ch2-2.html#de-boors-algorithm",
    "title": "3  Chapter 2.2",
    "section": "3.2 De Boor’s Algorithm 2",
    "text": "3.2 De Boor’s Algorithm 2\nSuppose a mesh density functoin is known on arbitrary background mesh:\n\\[\n\\mathcal{J}_{b}: y_1 = a &lt; y_2 &lt; \\dots &lt; y_K = b\n\\]\nThe idea is to approxmate \\(\\rho = \\rho(x)\\) on the background mesh by piecewise constant function:\n\\[\np(x) = \\begin{cases}\n    \\frac{1}{2}(\\rho(y_1) + \\rho(y_2)), x \\in [y_1, y_2) \\\\\n    \\frac{1}{2}(\\rho(y_{k-1}) + \\rho(y_k)), x \\in (y_{k-1}, y_k]\\\\\n    \\dots\\\\\n    \\frac{1}{2}(\\rho(y_{K-1} + \\rho(y_k))), x \\in (y_{K-1}, y_K]\n\\end{cases}\n\\]\nFind equidistributing mesh for the piecewise constant function. Denoting\n\\[\nP(x) = \\int^{x}_{a} p(x) dx\n\\]\nThen\n\\[\nP(y_j) = \\sum^{j}_{i=2}(y_i - y_{i-1})\\frac{\\rho(y_i) + \\rho(y_{i-1})}{2}, \\quad j = 2, \\dots, L\n\\]\nThe equadistributing can be interpreted as\n\\[\nP(x_j) = \\xi_j P(b=y_K), \\quad j=2,\\dots, N-1\n\\]\nSince \\(P(x)\\) is piecewise linear, \\(x_j\\) can be calculated from\n\\[\n(x_j - y_{k-1})\\frac{\\rho(y_{k-1}) + \\rho(y_k)}{2} = \\xi_j p(b) - p(y_{k-1})\n\\]\n\\[\nx_j = y_{k-1} + \\frac{2(\\xi_j P(b) - P(y_{k-1}))}{\\rho(y_{k-1}) + \\rho(y_k)}, \\quad 2 \\leq j \\leq N-1\n\\]\nThe converged mesh satisfies \\[\n(\\hat{x}_j - \\hat{x}_{j-1}) \\frac{\\rho(\\hat{x}_{j-1}) + \\rho(\\hat{x}_j)}{2} = (\\xi_j - \\xi_{j-1})\\hat{\\sigma}_h\n\\]\n\n\n\n\n\n\n\nDefinition 3.1 (Equidistribution quality measure) \\[\nQ_{eq}(x) = \\frac{\\rho x_{\\xi}}{\\sigma}\n\\]\nThe discrete version is\n\\[\nQ_{eq, j} = \\frac{\\rho(x_j) + \\rho(x_{j-1})}{2\\sigma_h}\\cdot \\frac{x_j - x_{j-1}}{\\xi_j - \\xi_{j-1}}, \\quad j=2,\\dots, N\n\\]\nwhere\n\\[\n\\sigma_h = \\sum^{N}_{j=2}\\frac{x_j - x_{j-1}}{\\xi_j - \\xi_{j-1}} \\cdot \\frac{\\rho(x_j) + \\rho(x_{j-1})}{2}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2.2</span>"
    ]
  },
  {
    "objectID": "Ch2-2.html#sec-example-2-2-1",
    "href": "Ch2-2.html#sec-example-2-2-1",
    "title": "3  Chapter 2.2",
    "section": "3.3 Example 2.2.1",
    "text": "3.3 Example 2.2.1\nConsider the mesh density function\n\\[\n\\begin{split}\n\\rho(x) &= 1 + 20 (1-\\tanh^2 (20 (x - 0.25))) + 30(1 - \\tanh^2(30(x - 0.5)))\\\\\n&+ 10 (1 - \\tanh^2(10(x - 0.75))), \\quad x\\in [0,1]\n\\end{split}\n\\]\n\n\"\"\"\nExample 2.2.1\n\"\"\"\n\nusing Pkg;\nPkg.activate(\".\");\nusing LinearAlgebra\nusing Plots\n\nfunction ρ(x)\n    1.0 + 20.0 * (1.0 - tanh(20 * (x - 0.25))^2) + 30.0 * (1.0 - tanh(30 * (x - 0.5))^2) + 10.0 * (1.0 - tanh(10 * (x - 0.75))^2)\nend\n\nfunction P(ys, ρ::F) where {F&lt;:Function}\n    len = length(ys)\n    y_right = view(ys, 2:len)\n    y_left = view(ys, 1:len-1)\n    y_diff = y_right .- y_left\n    ρ_sum = ρ.(y_right) .+ ρ.(y_left)\n    ps = cumsum(ρ_sum .* y_diff ./ 2)\n    return [0; ps] # ∫ᵃₐ = 0\nend\n\nfunction x_init(a, b, ngrid)\n    return range(a, b, length=ngrid)\nend\n\nfunction get_ξs(ngrid)\n    return range(0, 1, length=ngrid)\nend\n\nfunction step(ys, ρ::F) where {F&lt;:Function}\n    Ps = P(ys, ρ)\n    ξs = get_ξs(length(ys))\n    ξPb = ξs[2:end-1] .* Ps[end]\n    ks_l = searchsortedlast.(Ref(Ps), ξPb)\n    ks_r = ks_l .+ 1\n    xs_inter = @. ys[ks_l] + 2 * (ξPb - Ps[ks_l]) / (ρ(ys[ks_l]) + ρ(ys[ks_r]))\n    xs = [ys[1]; xs_inter; ys[end]]\n    return xs\nend\n\nfunction find_equidist(xs_init, ρ::F, maxIter=10000, tol=1e-8) where {F&lt;:Function}\n    xs = copy(xs_init)\n    qs = []\n    status = :fail\n    for _ in 1:maxIter\n        xs_new = step(xs, ρ)\n        if norm(xs_new - xs) &lt; 1e-8\n            status = :success\n            break\n        end\n        xs = xs_new\n        qs = [qs; Quality(xs, ρ)]\n    end\n    if status == :fail\n        @warn \"Failed to find equidistribution points\"\n    end\n    return (grid=xs, quality=qs, status=status)\nend\n\nfunction Quality(xs, ρ::F) where {F&lt;:Function}\n    ξs = get_ξs(length(xs))\n    x_diff = @. xs[2:end] - xs[1:end-1]\n    ξ_diff = @. ξs[2:end] - ξs[1:end-1]\n    σₕ = sum(@. (x_diff) * (ρ(xs[2:end]) + ρ(xs[1:end-1])) / 2)\n    Qs = @. (x_diff / ξ_diff) * (ρ(xs[2:end]) + ρ(xs[1:end-1])) / (2 * σₕ)\n    Qmax = maximum(abs.(Qs))\n    return Qmax\nend\n\nfunction plot_result(xs, ρ) where {F&lt;:Function}\n    p = plot()\n    plot!(p, ρ, 0, 1, label=\"ρ(x)\")\n    xlabel!(p, \"x\")\n    ylabel!(p, \"ρ(x)\")\n    scatter!(p, xs, ρ.(xs), label=\"equidistant points\")\n    return p\nend\n\n# Derivation\nys = x_init(0, 1, 81)\nres = find_equidist(ys, ρ)\nQmax = Quality(res.grid, ρ)\n\n# Display result\np1 = plot_result(res.grid, ρ)\np2 = plot(res.quality, label=\"Quality\", xlabel=\"Iteration\", ylabel=\"Quality\", legend=:bottomright)\nps = plot(p1, p2, layout=(1, 2))\ndisplay(ps)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2.2</span>"
    ]
  },
  {
    "objectID": "Ch2-2.html#boundary-value-problem",
    "href": "Ch2-2.html#boundary-value-problem",
    "title": "3  Chapter 2.2",
    "section": "3.4 Boundary Value Problem",
    "text": "3.4 Boundary Value Problem\nThe \\(x(\\xi)\\) satisfies the quasi-linear second-order differential equation:\n\\[\n\\frac{d}{d\\xi} \\left(\\rho(x) \\frac{dx}{d\\xi}\\right) = 0\n\\tag{3.2}\\]\nwith\n\\[\nx(0) = a, x(1) = b\n\\]\nEquation 3.2 can be sovled by minimizing variation formulation of corrdinate transformation:\n\\[\nI[x] = \\frac{1}{2}\\int^{1}_{0} \\left( \\rho(x)\\frac{dx}{d\\xi} \\right)^2 d\\xi\n\\tag{3.3}\\]\nThis is useful for multi-dimensinal case. Equation 3.3 is Equation 3.2 ’s Euler-Lagrange equation. The proof can be derived by apply an arbitrary function \\(\\delta x(0) = \\delta x(1) = 0\\), and \\(I[x+\\epsilon \\delta x]\\) 3.\nBy changing dependent variable,\n\\[\nI[\\xi] = \\frac{1}{2} \\int^{b}_{a} \\frac{1}{\\rho(x)}\\left(\\frac{d\\xi}{dx}\\right)^2 dx\n\\tag{3.4}\\]\nUnlike Equation 3.3, Equation 3.4 is a linear equation.\nEquation 3.2 can be discretized on computational mesh \\(\\mathbb{J}_{h}^c: \\xi_j, j=1,\\dots, N\\) with central finite differences:\n\\[\n\\begin{split}   \n    \\frac{1}{(\\xi_{j+1} - \\xi_{j-1})/2} \\left( \\frac{\\rho(x^{(n)}_{j+1}) + \\rho(x^{(n)}_{j})}{2} \\cdot \\frac{x^{(n+1)}_{j+1} - x^{(n+1)}_{j}}{\\xi_{j+1} - \\xi_j} - \\frac{\\rho(x^{(n)}_{j}) + \\rho(x^{(n)}_{j-1})}{2} \\cdot \\frac{x^{(n+1)}_{j} - x^{(n+1)}_{j-1}}{\\xi_{j} - \\xi_{j-1}}  \\right)\n\\end{split}\n\\tag{3.5}\\]\nKeeping \\(\\rho\\) fixed for the current iteration, the system is also fixed with boundarty condition:\n\\[\nx^{(n+1)}_1 = a, \\quad x^{(n+1)}_N = b\n\\]\n\n\n\n\n\n\nHow to solve Equation 3.5?\n\n\n\n\\[\n\\begin{bmatrix}\n   * & * & \\dots & \\dots\\\\\n     & * & * & \\dots\n\\end{bmatrix} \\begin{bmatrix} x_2 \\\\ \\vdots\\\\ x_{N-1}\\end{bmatrix} + \\begin{bmatrix} * x_1 \\\\ 0\\\\\\vdots \\\\ * x_N \\end{bmatrix} = \\begin{bmatrix}0 \\\\ \\vdots \\\\ 0 \\end{bmatrix}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2.2</span>"
    ]
  },
  {
    "objectID": "Ch2-2.html#computational-environment",
    "href": "Ch2-2.html#computational-environment",
    "title": "3  Chapter 2.2",
    "section": "3.5 Computational Environment",
    "text": "3.5 Computational Environment\n\nPkg.status()\n\nStatus `~/Documents/github/AdaptiveMovingMeshMethod.jl/code/Project.toml`\n  [91a5bcdd] Plots v1.40.4\n  [37e2e46d] LinearAlgebra\n\n\n\n\n\n\nHuang, Weizhang, and Robert D. Russell. 2011. Adaptive Moving Mesh Methods. Vol. 174. Applied Mathematical Sciences. New York, NY: Springer New York. https://doi.org/10.1007/978-1-4419-7916-2.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2.2</span>"
    ]
  },
  {
    "objectID": "Ch2-2.html#footnotes",
    "href": "Ch2-2.html#footnotes",
    "title": "3  Chapter 2.2",
    "section": "",
    "text": "(Huang and Russell 2011, 174:28)↩︎\n(Huang and Russell 2011, 174:36)↩︎\n(Huang and Russell 2011, 174:40)↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Chapter 2.2</span>"
    ]
  },
  {
    "objectID": "Ch2-3.html",
    "href": "Ch2-3.html",
    "title": "4  Chapter 2.3",
    "section": "",
    "text": "4.1 MMPDEs as coordinate transformation 1\nUse boundary value problem to coordinate transformation \\(x=x(\\xi, t)\\)\n\\[\n\\begin{split}\n    &\\frac{\\partial}{\\partial \\xi}\\left( \\rho(x,t)\\frac{\\partial x}{\\partial \\xi} \\right) = 0\\\\\n    &x(0,t) = a, x(1,t) = b\n\\end{split}\n\\tag{4.1}\\]\nThe moving mesh to minimize Equation 4.1 is by Euler-lagrange equation\n\\[\nI[\\xi] = \\frac{1}{2}\\int^{b}_{a} \\frac{1}{\\rho(x,{\\color{red}{t}})}\\left(\\frac{\\partial \\xi}{\\partial x}\\right)^2 dx\n\\]\nThe direction for \\(\\xi\\) that reduces \\(I[\\xi]\\) is given by the gradient:\n\\[\n\\frac{\\partial \\xi}{\\partial t} = - \\frac{P}{\\tau}\\frac{\\delta I}{\\delta \\xi}\n\\]\nAlso,\n\\[\n\\frac{\\delta I}{\\delta \\xi} = - \\frac{\\partial}{\\partial x}\\left(\\frac{1}{\\rho}\\frac{\\partial \\xi}{\\partial x}\\right)\n\\]\nCombining together,\n\\[\n\\frac{\\partial \\xi}{\\partial t} = \\frac{P}{\\tau}\\frac{\\partial}{\\partial x}\\left(\\frac{1}{\\rho} \\frac{\\partial \\xi}{\\partial x}\\right)\n\\tag{4.2}\\]\nSince Equation 4.2 is the path for computational domain, the physical domain path can be derived by chaning dependen/independent variables:\n\\[\n\\frac{\\partial x}{\\partial t} = \\frac{1}{\\tau}\\frac{\\partial x}{\\partial \\xi} P\\left( \\rho \\frac{\\partial x}{\\partial \\xi} \\right)^{ -2} \\left( \\frac{\\partial x}{\\partial \\xi} \\right)^{-1} \\frac{\\partial}{\\partial \\xi}\\left(\\rho \\frac{\\partial x}{\\partial \\xi}\\right)\n\\]\nChoose \\(P = (\\rho x_\\xi)^2\\):\n\\[\n(\\text{MMPDE5}): \\quad \\frac{\\partial x}{\\partial t} = \\frac{1}{\\tau} \\frac{\\partial}{\\partial \\xi} \\left(\\rho \\frac{\\partial x}{\\partial \\xi}\\right)\n\\]\nAnother choise of \\(P = (\\rho x_\\xi)^2 / \\rho\\) to make mesh more spatially balanced throughout the physical domain:\n\\[\n(\\text{modified MMPDE5}): \\frac{\\partial x}{\\partial t} = \\frac{1}{\\tau \\rho}\\frac{\\partial}{\\partial \\xi} \\left( \\rho \\frac{\\partial x}{\\partial \\xi}\\right)\n\\tag{4.3}\\]\nDicretization of Equation 4.3 can be done with central finite differences on uniform computational mesh on\n\\[\n\\frac{dx_j}{dt} = \\frac{1}{\\rho_j \\tau \\Delta \\xi^2} \\left[ \\frac{\\rho_{j+1} + \\rho_j}{2}(x_{j+1} - x_j) - \\frac{\\rho_j + \\rho_{j-1}}{2} (x_{j} - x_{j-1}) \\right]\n\\tag{4.4}\\]\nwhere \\(x_j = x(\\xi_j, t)\\), \\(\\rho_j = \\rho(x_j, t)\\), and \\(\\Delta \\xi = \\xi_{j+1} - \\xi_j\\).\nfor \\(j=2, \\dots, N-1\\), \\(x_j \\approx x(\\xi_i, t)\\) and \\(\\rho_j = \\rho(x_j,t)\\). The dependence of \\(rho\\) on \\(x\\) and \\(t\\) is by physical solution \\(u=u(x,t)\\) such that\n\\[\n\\rho_j = \\rho(u(x_j, t))\n\\]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2.3</span>"
    ]
  },
  {
    "objectID": "Ch2-3.html#mmpdes-as-coordinate-transformation",
    "href": "Ch2-3.html#mmpdes-as-coordinate-transformation",
    "title": "4  Chapter 2.3",
    "section": "",
    "text": "\\(\\tau &gt; 0\\): user specified parameter for adjusting the response time of mesh movement of changes in \\(\\rho(x,t)\\)\n\\(P\\): positive-definite differential operator",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2.3</span>"
    ]
  },
  {
    "objectID": "Ch2-3.html#example-2.3.1",
    "href": "Ch2-3.html#example-2.3.1",
    "title": "4  Chapter 2.3",
    "section": "4.2 Example 2.3.1",
    "text": "4.2 Example 2.3.1\nUse Equation 4.3 to solve Section 3.3\n\n\"\"\"\nExample 2.3.1\n\"\"\"\n\nusing Pkg;\nPkg.activate(\".\");\nusing LinearAlgebra\nusing Plots\nusing DifferentialEquations\n\nfunction ρ(x)\n    1.0 + 20.0 * (1.0 - tanh(20 * (x - 0.25))^2) + 30.0 * (1.0 - tanh(30 * (x - 0.5))^2) + 10.0 * (1.0 - tanh(10 * (x - 0.75))^2)\nend\n\nfunction mmpde5_modified!(dx, x, p, t)\n    τ, Δξ = p \n\n    # Bounday mesh in physical domain\n    dx[1] = 0.0 \n    dx[end] = 0.0\n\n    # Interior mesh\n    for i in 2:length(x)-1\n        coeff = (ρ(i)*τ*Δξ^2)^-1\n        x_diff_r = x[i+1] - x[i]\n        x_diff_l = x[i] - x[i-1]\n        ρ_sum_r = ρ(x[i+1]) + ρ(x[i])\n        ρ_sum_l = ρ(x[i]) + ρ(x[i-1])\n        dx[i] = coeff * (0.5* ρ_sum_r * x_diff_r - 0.5 * ρ_sum_l * x_diff_l)\n    end\nend\n\nfunction Quality(xs, ρ::F) where {F&lt;:Function}\n    ξs = range(0,1,length(xs))\n    x_diff = @. xs[2:end] - xs[1:end-1]\n    ξ_diff = @. ξs[2:end] - ξs[1:end-1]\n    σₕ = sum(@. (x_diff) * (ρ(xs[2:end]) + ρ(xs[1:end-1])) / 2)\n    Qs = @. (x_diff / ξ_diff) * (ρ(xs[2:end]) + ρ(xs[1:end-1])) / (2 * σₕ)\n    Qmax = maximum(abs.(Qs))\n    return Qmax\nend\n\nfunction plot_result(xs, ρ) where {F&lt;:Function}\n    p = plot()\n    plot!(p, ρ, 0, 1, label=\"ρ(x)\", legend=:topright, xlabel=\"x\", ylabel=\"ρ(x)\")\n    scatter!(p, xs, ρ.(xs), label=\"equi mesh\")\n    return p\nend\n\n\n# Derive equidistant points\nngrid = 81\np = (τ=1., Δξ=1. / (ngrid -1))\ntspan = (0., 1.)\nx_init = collect(range(0, 1, length=ngrid))\nprob = ODEProblem(mmpde5_modified!, collect(x_init), tspan, p)\nsol = solve(prob, ImplicitEuler())\n\n# Plot\nplt1 = plot_result(sol(tspan[end]), ρ)\nplt2 = plot(Quality.(sol.(0:0.01:1), Ref(ρ)), xlabel=\"Time\", ylabel=\"Quality\", label=\"Quality\", legend=:topright)\nplts = plot(plt1, plt2, layout=(1, 2))\ndisplay(plts)",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2.3</span>"
    ]
  },
  {
    "objectID": "Ch2-3.html#mmpde-as-inverse-corrdintate-tranformation",
    "href": "Ch2-3.html#mmpde-as-inverse-corrdintate-tranformation",
    "title": "4  Chapter 2.3",
    "section": "4.3 MMPDE as inverse corrdintate tranformation 2",
    "text": "4.3 MMPDE as inverse corrdintate tranformation 2\nUse inverse coordinate transformation \\(\\xi(x,t)\\):\n\\[\n(\\text{MMPDE5xi})\\quad \\frac{\\partial \\xi}{\\partial t} = \\frac{1}{\\tau} \\frac{\\partial}{\\partial}(\\frac{1}{\\rho}\\frac{\\partial \\xi}{\\partial x})\n\\tag{4.5}\\]\n\n\n\n\n\n\n\nPhysical mesh\nComputational mesh\n\n\n\n\n\\(\\mathcal{J}_{h}^{n}: x_{j}^{n}\\approx x(\\xi_j, t_n), j=1,\\dots, N\\)\n\\(\\mathcal{J}_{h}^{c}: \\xi_j = \\frac{j-1}{N-1}, j=1,\\dots, N\\)\n\n\n\nDiscretization of Equation 4.5 becomes\n\\[\n\\begin{split}\n\\frac{\\xi^{n+1}_j - \\xi^{n}_{j}}{\\Delta t} &= \\frac{2}{\\tau (x^{n}_{j+1} - x^{n}_{j-1})} \\left( \\frac{\\xi^{n+1}_{j+1} - \\xi^{n+1}_{j}}{x^{n}_{j+1} - x^{n}_j}\\frac{2}{\\rho^{n}_{j+1} + \\rho^{n}_{j}}\\\\\n- \\frac{\\xi^{n+1}_j - \\xi^{n+1}_{j-1}}{x^{n}_j - x^{n}_{j-1}} \\frac{2}{\\rho^{n}_j + \\rho^{n}_{j-1}}\\right)\n\\end{split}\n\\tag{4.6}\\]\nboundary conditions\n\\[\n\\begin{split}\n    \\xi^{n+1}_1 &= 0\\\\\n    \\xi^{n+1}_N &= 1\n\\end{split}\n\\tag{4.7}\\]\nEquation 4.6 and Equation 4.7 gives new computational mesh:\n\\[\n\\mathcal{J}^{c, n+1}_h : \\xi^{n+1}_j, j = 1, \\dots, N\n\\]\nSince mesh density function is computed at \\(t=t_n\\). \\(\\rho^{n}_j = \\rho(x^{n}_j, t_n)\\). Thus\n\nEquation 4.6 is linear\nThere is time lagging problem\n\nAdvantages of inverse coordinate transformation\n\n\n\n\n\n\n\nPhysical to Comp.\nComp. to Physical\n\n\n\n\n\\(\\frac{d}{d\\xi}\\left(\\rho(x(\\xi))\\frac{dx(\\xi)}{d\\xi}\\right)=0\\)\n\\(\\frac{d}{dx}\\left(\\frac{1}{\\rho(x)} \\frac{d\\xi(x)}{dx}\\right)=0\\)\n\n\nQuasi-linear second-order DE\nLinear second-order DE\n\n\n\nLinearity -&gt; easy to ensure existence, uniqueness and well-poseness in multi-dimensions\n\n\n\n\n4.3.1 Example 2.3.2\nAssume \\(\\tau=1\\), use MMPDE5xi Equation 4.5 to solve Section 3.3\n\n\"\"\"\nExample 2.3.2\n\"\"\"\n\nusing Pkg;\nPkg.activate(\".\");\nusing LinearAlgebra\nusing Plots\nusing DifferentialEquations\nusing DiffEqCallbacks\nusing Interpolations \n\nfunction plot_result(xs, ρ) where {F&lt;:Function}\n    p = plot()\n    plot!(p, ρ, 0, 1, label=\"ρ(x)\", legend=:topright, xlabel=\"x\", ylabel=\"ρ(x)\")\n    scatter!(p, xs, ρ.(xs), label=\"equi mesh\")\n    return p\nend\n\nfunction ρ(x)\n    1.0 + 20.0 * (1.0 - tanh(20 * (x - 0.25))^2) + 30.0 * (1.0 - tanh(30 * (x - 0.5))^2) + 10.0 * (1.0 - tanh(10 * (x - 0.75))^2)\nend\n\nfunction Quality(xs, ρ::F) where {F&lt;:Function}\n    ξs = range(0,1,length(xs))\n    x_diff = @. xs[2:end] - xs[1:end-1]\n    ξ_diff = @. ξs[2:end] - ξs[1:end-1]\n    σₕ = sum(@. (x_diff) * (ρ(xs[2:end]) + ρ(xs[1:end-1])) / 2)\n    Qs = @. (x_diff / ξ_diff) * (ρ(xs[2:end]) + ρ(xs[1:end-1])) / (2 * σₕ)\n    Qmax = maximum(abs.(Qs))\n    return Qmax\nend\n\nfunction mmpde5xi!(dξ, ξ, p, t)\n    τ, xs = p \n    # Boundary mesh in computational domain\n    dξ[1] = 0.0\n    dξ[end] = 0.\n    # Interior mesh\n    for i in 2:length(ξ)-1\n        coeff = 2 * (τ * (xs[i+1] - xs[i-1]))^-1\n        ρ_l_inv = 2 * (ρ(xs[i+1]) + ρ(xs[i]))^-1\n        ρ_r_inv = 2 * (ρ(xs[i]) + ρ(xs[i-1]))^-1\n        ρξ_l = ρ_l_inv * (ξ[i+1] - ξ[i]) / (xs[i+1] - xs[i])\n        ρξ_r = ρ_r_inv * (ξ[i] - ξ[i-1]) / (xs[i] - xs[i-1])\n        dξ[i] = coeff * (ρξ_l - ρξ_r)\n    end\nend\n\n\nfunction affect!(int)\n    ξ = int.u\n    xs = int.p[2]\n    interf = linear_interpolation(ξ, xs)\n    xs_new = interf.(range(0, stop=1, length=length(ξ))[2:end-1])\n    xs_new = [0.; xs_new; 1.] # set boundary points at physical domain\n    int.p[2] = xs_new\nend\n\ncondition = function (u, t, integrator)\n    true\nend\n\nevent = DiscreteCallback(condition, affect!)\nngrid = 81\nξ0 = collect(range(0, stop=1, length=100))\nx0 = collect(range(0, stop=1, length=100))\np = [1.0, x0]\ntspan = (0., 1.)\nprob = ODEProblem{true}(mmpde5xi!, ξ0, tspan, p)\nsol = solve(prob, Tsit5(), callback = event)\n\n\n# plot \nxs = p[2]\nplt1 = plot_result(xs, ρ)\ndisplay(plt1)\n@show Quality(xs, ρ)\n\n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n  \n    \n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuality(xs, ρ) = 1.0383968302870894\n\n\n1.0383968302870894\n\n\n\n\n\n\n\n\nWhy does \\(\\xi\\) move in time?\n\n\n\nEquation 4.6 might be counterintuitive in the beginning. This can be interptet as:\n\nThe mapping of \\(\\xi\\) to \\(x\\) is not optimal when progresses in time. So every time step, we use \\(x^{n}\\) and \\(\\xi^{n+1}\\) to approximate the mapping.\nAnother equidistribution at \\(n+1\\) is achieved by mapping \\(x^{n+1}\\) from uniform \\(\\xi\\)\n\n\n\n\n\n\n\nHuang, Weizhang, and Robert D. Russell. 2011. Adaptive Moving Mesh Methods. Vol. 174. Applied Mathematical Sciences. New York, NY: Springer New York. https://doi.org/10.1007/978-1-4419-7916-2.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2.3</span>"
    ]
  },
  {
    "objectID": "Ch2-3.html#footnotes",
    "href": "Ch2-3.html#footnotes",
    "title": "4  Chapter 2.3",
    "section": "",
    "text": "(Huang and Russell 2011, 174:43)↩︎\n(Huang and Russell 2011, 174:50)↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Chapter 2.3</span>"
    ]
  },
  {
    "objectID": "ref.html",
    "href": "ref.html",
    "title": "5  References",
    "section": "",
    "text": "Huang, Weizhang, and Robert D. Russell. 2011. Adaptive Moving\nMesh Methods. Vol. 174. Applied Mathematical\nSciences. New York, NY: Springer New York. https://doi.org/10.1007/978-1-4419-7916-2.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>References</span>"
    ]
  }
]